//
// Complete OLED Display Functions for ECE 355 Lab
// Make sure you have these includes at the top of main.c:
//
#include <stdio.h>
#include "diag/Trace.h"
#include <string.h>
#include "cmsis/cmsis_device.h"
//

// These should be declared as GLOBAL variables (outside any function, before main):
unsigned int Freq = 0;  // Measured frequency value
unsigned int Res = 0;   // Measured resistance value
SPI_HandleTypeDef SPI_Handle;

// LED Display initialization commands
unsigned char oled_init_cmds[] =
{
    0xAE,
    0x20, 0x00,
    0x40,
    0xA0 | 0x01,
    0xA8, 0x40 - 1,
    0xC0 | 0x08,
    0xD3, 0x00,
    0xDA, 0x32,
    0xD5, 0x80,
    0xD9, 0x22,
    0xDB, 0x30,
    0x81, 0xFF,
    0xA4,
    0xA6,
    0xAD, 0x30,
    0x8D, 0x10,
    0xAE | 0x01,
    0xC0,
    0xA0
};

// Character specifications for LED Display (see document for full array)
// This is the full Characters array from the lab website
unsigned char Characters[][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // SPACE (indices 0-31)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // SPACE (32)
    {0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00},  // ! (33)
    {0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00},  // " (34)
    {0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00, 0x00, 0x00},  // # (35)
    {0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00, 0x00, 0x00},  // $ (36)
    {0x23, 0x13, 0x08, 0x64, 0x62, 0x00, 0x00, 0x00},  // % (37)
    {0x36, 0x49, 0x55, 0x22, 0x50, 0x00, 0x00, 0x00},  // & (38)
    {0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},  // ' (39)
    {0x00, 0x1C, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00},  // ( (40)
    {0x00, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00, 0x00},  // ) (41)
    {0x14, 0x08, 0x3E, 0x08, 0x14, 0x00, 0x00, 0x00},  // * (42)
    {0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00, 0x00},  // + (43)
    {0x00, 0x50, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00},  // , (44)
    {0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00},  // - (45)
    {0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00},  // . (46)
    {0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00},  // / (47)
    {0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x00, 0x00},  // 0 (48)
    {0x00, 0x42, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00},  // 1 (49)
    {0x42, 0x61, 0x51, 0x49, 0x46, 0x00, 0x00, 0x00},  // 2 (50)
    {0x21, 0x41, 0x45, 0x4B, 0x31, 0x00, 0x00, 0x00},  // 3 (51)
    {0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, 0x00, 0x00},  // 4 (52)
    {0x27, 0x45, 0x45, 0x45, 0x39, 0x00, 0x00, 0x00},  // 5 (53)
    {0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00, 0x00, 0x00},  // 6 (54)
    {0x03, 0x01, 0x71, 0x09, 0x07, 0x00, 0x00, 0x00},  // 7 (55)
    {0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, 0x00},  // 8 (56)
    {0x06, 0x49, 0x49, 0x29, 0x1E, 0x00, 0x00, 0x00},  // 9 (57)
    {0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00},  // : (58)
    {0x00, 0x56, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00},  // ; (59)
    {0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00},  // < (60)
    {0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00},  // = (61)
    {0x00, 0x41, 0x22, 0x14, 0x08, 0x00, 0x00, 0x00},  // > (62)
    {0x02, 0x01, 0x51, 0x09, 0x06, 0x00, 0x00, 0x00},  // ? (63)
    {0x32, 0x49, 0x79, 0x41, 0x3E, 0x00, 0x00, 0x00},  // @ (64)
    {0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00, 0x00, 0x00},  // A (65)
    {0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, 0x00},  // B (66)
    {0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, 0x00, 0x00},  // C (67)
    {0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00},  // D (68)
    {0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00, 0x00},  // E (69)
    {0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00, 0x00},  // F (70)
    {0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00, 0x00, 0x00},  // G (71)
    {0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x00, 0x00},  // H (72)
    {0x40, 0x41, 0x7F, 0x41, 0x40, 0x00, 0x00, 0x00},  // I (73)
    {0x20, 0x40, 0x41, 0x3F, 0x01, 0x00, 0x00, 0x00},  // J (74)
    {0x7F, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00},  // K (75)
    {0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00},  // L (76)
    {0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00, 0x00, 0x00},  // M (77)
    {0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00, 0x00, 0x00},  // N (78)
    {0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x00, 0x00},  // O (79)
    {0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00, 0x00},  // P (80)
    {0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00, 0x00, 0x00},  // Q (81)
    {0x7F, 0x09, 0x19, 0x29, 0x46, 0x00, 0x00, 0x00},  // R (82)
    {0x46, 0x49, 0x49, 0x49, 0x31, 0x00, 0x00, 0x00},  // S (83)
    {0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, 0x00, 0x00},  // T (84)
    {0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00, 0x00, 0x00},  // U (85)
    {0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, 0x00, 0x00},  // V (86)
    {0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00, 0x00, 0x00},  // W (87)
    {0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x00, 0x00},  // X (88)
    {0x07, 0x08, 0x70, 0x08, 0x07, 0x00, 0x00, 0x00},  // Y (89)
    {0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x00, 0x00},  // Z (90)
    {0x7F, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // [ (91)
    {0x15, 0x16, 0x7C, 0x16, 0x15, 0x00, 0x00, 0x00},  // backslash (92)
    {0x00, 0x00, 0x00, 0x41, 0x7F, 0x00, 0x00, 0x00},  // ] (93)
    {0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00},  // ^ (94)
    {0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00},  // _ (95)
    {0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00},  // ` (96)
    {0x20, 0x54, 0x54, 0x54, 0x78, 0x00, 0x00, 0x00},  // a (97)
    {0x7F, 0x48, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00},  // b (98)
    {0x38, 0x44, 0x44, 0x44, 0x20, 0x00, 0x00, 0x00},  // c (99)
    {0x38, 0x44, 0x44, 0x48, 0x7F, 0x00, 0x00, 0x00},  // d (100)
    {0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x00, 0x00},  // e (101)
    {0x08, 0x7E, 0x09, 0x01, 0x02, 0x00, 0x00, 0x00},  // f (102)
    {0x0C, 0x52, 0x52, 0x52, 0x3E, 0x00, 0x00, 0x00},  // g (103)
    {0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, 0x00},  // h (104)
    {0x00, 0x44, 0x7D, 0x40, 0x00, 0x00, 0x00, 0x00},  // i (105)
    {0x20, 0x40, 0x44, 0x3D, 0x00, 0x00, 0x00, 0x00},  // j (106)
    {0x7F, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00},  // k (107)
    {0x00, 0x41, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00},  // l (108)
    {0x7C, 0x04, 0x18, 0x04, 0x78, 0x00, 0x00, 0x00},  // m (109)
    {0x7C, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, 0x00},  // n (110)
    {0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00},  // o (111)
    {0x7C, 0x14, 0x14, 0x14, 0x08, 0x00, 0x00, 0x00},  // p (112)
    {0x08, 0x14, 0x14, 0x18, 0x7C, 0x00, 0x00, 0x00},  // q (113)
    {0x7C, 0x08, 0x04, 0x04, 0x08, 0x00, 0x00, 0x00},  // r (114)
    {0x48, 0x54, 0x54, 0x54, 0x20, 0x00, 0x00, 0x00},  // s (115)
    {0x04, 0x3F, 0x44, 0x40, 0x20, 0x00, 0x00, 0x00},  // t (116)
    {0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00, 0x00, 0x00},  // u (117)
    {0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00, 0x00, 0x00},  // v (118)
    {0x3C, 0x40, 0x38, 0x40, 0x3C, 0x00, 0x00, 0x00},  // w (119)
    {0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00},  // x (120)
    {0x0C, 0x50, 0x50, 0x50, 0x3C, 0x00, 0x00, 0x00},  // y (121)
    {0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, 0x00, 0x00},  // z (122)
    {0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x00},  // { (123)
    {0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00},  // | (124)
    {0x00, 0x41, 0x36, 0x08, 0x00, 0x00, 0x00, 0x00},  // } (125)
    {0x08, 0x08, 0x2A, 0x1C, 0x08, 0x00, 0x00, 0x00},  // ~ (126)
    {0x08, 0x1C, 0x2A, 0x08, 0x08, 0x00, 0x00, 0x00}   // <- (127)
};

// Function prototypes (add these near the top, after includes):
void oled_Write(unsigned char Value);
void oled_Write_Cmd(unsigned char cmd);
void oled_Write_Data(unsigned char data);
void oled_config(void);
void refresh_OLED(char * text);


// ============= FUNCTION IMPLEMENTATIONS =============

void refresh_OLED(char * text)
{
    // Buffer size = at most 16 characters per PAGE + terminating '\0'
    char Buffer[17];  // Changed to char instead of unsigned char

    // Display resistance on PAGE 2
    //snprintf(Buffer, sizeof(Buffer), "R: %5u Ohms", Res);
    snprintf(Buffer, sizeof(Buffer), "%s", text);

    // Select PAGE 2, set starting SEG to 2
    oled_Write_Cmd(0xB2);  // Select PAGE 2 (1011 0010)
    oled_Write_Cmd(0x02);  // Set lower column address (SEG lower nibble = 0010)
    oled_Write_Cmd(0x10);  // Set upper column address (SEG upper nibble = 0000)

    // Send each character to display
    for (int i = 0; Buffer[i] != '\0'; i++)
    {
        unsigned char c = Buffer[i];
        for (int j = 0; j < 8; j++)
        {
            oled_Write_Data(Characters[c][j]);
        }
    }

    // Display frequency on PAGE 4
    //snprintf(Buffer, sizeof(Buffer), "F: %5u Hz", Freq);
    snprintf(Buffer, sizeof(Buffer), "%s", text);

    // Select PAGE 4, set starting SEG to 2
    oled_Write_Cmd(0xB6);  // Select PAGE 4 (1011 0100)
    oled_Write_Cmd(0x04);  // Set lower column address
    oled_Write_Cmd(0x12);  // Set upper column address

    // Send each character to display
    for (int i = 0; Buffer[i] != '\0'; i++)
    {
        unsigned char c = Buffer[i];
        for (int j = 0; j < 8; j++)
        {
            oled_Write_Data(Characters[c][j]);
        }
    }

    // Wait for ~100 ms using TIM3 for ~10 frames/sec refresh rate
    // Note: You need to configure TIM3 first in your main() or init code
    // Assuming TIM3 is configured with a suitable prescaler
    // Adjust the count value based on your actual TIM3 clock configuration
    TIM3->CNT = 0;
    while (TIM3->CNT < 4800);  // Adjust this value for your clock settings
}


void oled_Write_Cmd(unsigned char cmd)
{
    GPIOB->BSRR = (1 << 8);   // Set PB8 (CS#) = 1
    GPIOB->BRR = (1 << 9);    // Clear PB9 (D/C#) = 0 for command
    GPIOB->BRR = (1 << 8);    // Clear PB8 (CS#) = 0
    oled_Write(cmd);
    GPIOB->BSRR = (1 << 8);   // Set PB8 (CS#) = 1
}


void oled_Write_Data(unsigned char data)
{
    GPIOB->BSRR = (1 << 8);   // Set PB8 (CS#) = 1
    GPIOB->BSRR = (1 << 9);   // Set PB9 (D/C#) = 1 for data
    GPIOB->BRR = (1 << 8);    // Clear PB8 (CS#) = 0
    oled_Write(data);
    GPIOB->BSRR = (1 << 8);   // Set PB8 (CS#) = 1
}


void oled_Write(unsigned char Value)
{
    // Wait until SPI2 is ready for writing (TXE = 1 in SPI2_SR)
    while ((SPI2->SR & SPI_SR_TXE) == 0);

    // Send one 8-bit character
    // This function also sets BIDIOE = 1 in SPI2_CR1
    HAL_SPI_Transmit(&SPI_Handle, &Value, 1, HAL_MAX_DELAY);

    // Wait until transmission is complete (TXE = 1 in SPI2_SR)
    while ((SPI2->SR & SPI_SR_TXE) == 0);
}


void oled_config(void)
{
    // Enable GPIOB clock
    RCC->AHBENR |= RCC_AHBENR_GPIOBEN;

    // Configure PB8, PB9, PB11 as outputs (mode = 01 for general purpose output)
    // Each pin uses 2 bits in MODER register
    // Clear bits first
    GPIOB->MODER &= ~((3 << (8*2)) | (3 << (9*2)) | (3 << (11*2)));
    // Set to 01 (output mode)
    GPIOB->MODER |= ((1 << (8*2)) | (1 << (9*2)) | (1 << (11*2)));

    // Configure PB13 and PB15 as alternate function (mode = 10)
    GPIOB->MODER &= ~((3 << (13*2)) | (3 << (15*2)));
    GPIOB->MODER |= ((2 << (13*2)) | (2 << (15*2)));

    // Set alternate function to AF0 for PB13 and PB15
    // AFR[1] is for pins 8-15
    // PB13 is bit position (13-8)*4 = 20
    // PB15 is bit position (15-8)*4 = 28
    GPIOB->AFR[1] &= ~((0xF << 20) | (0xF << 28));
    // AF0 = 0000, so we just clear the bits (already done above)

    // Enable SPI2 clock
    RCC->APB1ENR |= RCC_APB1ENR_SPI2EN;

    // Initialize SPI2 structure
    SPI_Handle.Instance = SPI2;
    SPI_Handle.Init.Direction = SPI_DIRECTION_1LINE;
    SPI_Handle.Init.Mode = SPI_MODE_MASTER;
    SPI_Handle.Init.DataSize = SPI_DATASIZE_8BIT;
    SPI_Handle.Init.CLKPolarity = SPI_POLARITY_LOW;
    SPI_Handle.Init.CLKPhase = SPI_PHASE_1EDGE;
    SPI_Handle.Init.NSS = SPI_NSS_SOFT;
    SPI_Handle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;
    SPI_Handle.Init.FirstBit = SPI_FIRSTBIT_MSB;
    SPI_Handle.Init.CRCPolynomial = 7;

    // Initialize the SPI interface
    HAL_SPI_Init(&SPI_Handle);

    // Enable the SPI
    __HAL_SPI_ENABLE(&SPI_Handle);

    // Reset LED Display (RES# = PB11)
    GPIOB->BRR = (1 << 11);         // Set PB11 = 0 (active low reset)
    for (volatile int i = 0; i < 100000; i++);  // Wait a few ms

    GPIOB->BSRR = (1 << 11);        // Set PB11 = 1 (release reset)
    for (volatile int i = 0; i < 100000; i++);  // Wait a few ms

    // Send initialization commands to LED Display
    for (unsigned int i = 0; i < sizeof(oled_init_cmds); i++)
    {
        oled_Write_Cmd(oled_init_cmds[i]);
    }

    // Fill LED Display data memory (GDDRAM) with zeros
    for (unsigned int page = 0; page < 8; page++)
    {
        // Select PAGE
        oled_Write_Cmd(0xB0 | page);  // PAGE address: 1011 0xxx

        // Set starting SEG = 0
        oled_Write_Cmd(0x00);  // Lower column address = 0000
        oled_Write_Cmd(0x10);  // Upper column address = 0000

        // Write 128 zeros to clear the page
        for (unsigned int col = 0; col < 128; col++)
        {
            oled_Write_Data(0x00);
        }
    }
}


// ============= EXAMPLE MAIN FUNCTION =============
// Your main function should look something like this:


int main(int argc, char* argv[])
{
   // SystemClock48MHz();

    // Your other initializations here (ADC, DAC, TIM2, TIM3, etc.)

    oled_config();  // Initialize the OLED display
    char * text1 = "Test";
    int on = 1000;
    int off = 0;
    while (1)
    {
    	refresh_OLED(text1);


    }
}

